"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const utils_1 = require("../../utils");
const instruments_1 = require("../tracing/metrics/instruments");
exports.addRequestMetricsMiddleware = () => {
    const concurrentRequests = instruments_1.createConcurrentRequestsInstrument();
    const requestTimings = instruments_1.createRequestsTimingsInstrument();
    const totalRequests = instruments_1.createTotalRequestsInstrument();
    const responseSizes = instruments_1.createRequestsResponseSizesInstrument();
    const abortedRequests = instruments_1.createTotalAbortedRequestsInstrument();
    return async function addRequestMetrics(ctx, next) {
        const start = process.hrtime();
        concurrentRequests.inc(1);
        ctx.req.once('aborted', () => abortedRequests.inc({ ["handler" /* REQUEST_HANDLER */]: ctx.requestHandlerName }, 1));
        let responseClosed = false;
        ctx.res.once('close', () => (responseClosed = true));
        try {
            await next();
        }
        finally {
            const responseLength = ctx.response.length;
            if (responseLength) {
                responseSizes.observe({ ["handler" /* REQUEST_HANDLER */]: ctx.requestHandlerName }, responseLength);
            }
            totalRequests.inc({
                ["handler" /* REQUEST_HANDLER */]: ctx.requestHandlerName,
                ["status_code" /* STATUS_CODE */]: ctx.response.status,
            }, 1);
            const onResFinished = () => {
                requestTimings.observe({
                    ["handler" /* REQUEST_HANDLER */]: ctx.requestHandlerName,
                }, utils_1.hrToMillisFloat(process.hrtime(start)));
                concurrentRequests.dec(1);
            };
            if (responseClosed) {
                onResFinished();
            }
            else {
                stream_1.finished(ctx.res, onResFinished);
            }
        }
    };
};
