"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRoutes = void 0;
const api_1 = require("@vtex/api");
const co_body_1 = require("co-body");
async function readBody(ctx, next) {
    const reqBody = await co_body_1.json(ctx.req);
    ctx.state.requestBody = reqBody;
    await next();
}
const buildRoutes = (Connector, middlewares) => {
    var _a, _b, _c, _d, _e;
    return {
        authorize: [
            readBody,
            ...((_a = middlewares === null || middlewares === void 0 ? void 0 : middlewares.authorize) !== null && _a !== void 0 ? _a : []),
            api_1.method({
                POST: [
                    async function postAuthorizations(ctx, next) {
                        const connector = new Connector(ctx);
                        const reqBody = ctx.state.requestBody;
                        ctx.body = await connector.authorize(reqBody);
                        ctx.status = 200;
                        await next();
                    },
                ],
            }),
        ],
        settle: [
            readBody,
            ...((_b = middlewares === null || middlewares === void 0 ? void 0 : middlewares.settle) !== null && _b !== void 0 ? _b : []),
            api_1.method({
                POST: [
                    async function postSettlements(ctx, next) {
                        const connector = new Connector(ctx);
                        const reqBody = ctx.state.requestBody;
                        ctx.body = await connector.settle(reqBody);
                        ctx.status = 200;
                        await next();
                    },
                ],
            }),
        ],
        refund: [
            readBody,
            ...((_c = middlewares === null || middlewares === void 0 ? void 0 : middlewares.refund) !== null && _c !== void 0 ? _c : []),
            api_1.method({
                POST: [
                    async function postRefunds(ctx, next) {
                        const connector = new Connector(ctx);
                        const reqBody = ctx.state.requestBody;
                        ctx.body = await connector.refund(reqBody);
                        ctx.status = 200;
                        await next();
                    },
                ],
            }),
        ],
        cancel: [
            readBody,
            ...((_d = middlewares === null || middlewares === void 0 ? void 0 : middlewares.cancel) !== null && _d !== void 0 ? _d : []),
            api_1.method({
                POST: [
                    async function postCancellations(ctx, next) {
                        const connector = new Connector(ctx);
                        const reqBody = ctx.state.requestBody;
                        ctx.body = await connector.cancel(reqBody);
                        ctx.status = 200;
                        await next();
                    },
                ],
            }),
        ],
        inbound: [
            readBody,
            ...((_e = middlewares === null || middlewares === void 0 ? void 0 : middlewares.inbound) !== null && _e !== void 0 ? _e : []),
            api_1.method({
                POST: [
                    async function postInbound(ctx, next) {
                        const connector = new Connector(ctx);
                        const reqBody = ctx.state.requestBody;
                        if (connector.inbound) {
                            ctx.body = await connector.inbound(reqBody);
                            ctx.status = 200;
                        }
                        else {
                            ctx.status = 501;
                        }
                        await next();
                    },
                ],
            }),
        ],
    };
};
exports.buildRoutes = buildRoutes;
